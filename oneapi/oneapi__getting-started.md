# Getting Started
Source: https://help.zscaler.com/oneapi/getting-started
PDF: https://help.zscaler.com/pdf/com/en/1497121.pdf

Zscaler OneAPI uses the OAuth 2.0 authorization framework to provide secure access to Zscaler Internet Access (ZIA), Zscaler Private Access (ZPA), Zscaler Client Connector, and Zscaler Cloud & Branch Connector APIs. OAuth 2.0 allows third-party applications to obtain limited delegated access to protected resources using access tokens, instead of static, stored credentials. OneAPI uses the [Client Credentials OAuth flow](https://oauth.net/2/grant-types/), in which client applications can exchange their credentials with the authorization server for an access token and obtain access to the API resources, without any user authentication involved in the process.
Zscaler's unified identity platform, [ZIdentity](/zidentity/what-zidentity), serves as the authorization server for OneAPI and exposes a token endpoint to the client applications for obtaining access tokens required for authentication. The Zscaler API server acts as the resource server and the access tokens are issued for this resource server. The API client applications are registered in the ZIdentity Admin Portal, along with their authentication information, service entitlements, and necessary scope to access the required API resources.
ZIdentity supports the following client authentication mechanisms for accessing OneAPI resources:
- **Client Secret**: A client secret generated in the ZIdentity Admin Portal is used for authentication. This authentication method requires manual key rotation in ZIdentity.
- **Private Key JWT**: A JSON Web Token (JWT) assertion generated by the client and signed by the client's private key is used for authentication. The client assertion is verified by the authorization server (i.e., ZIdentity) using the client's public key. To learn more, refer to [RFC 7523](https://datatracker.ietf.org/doc/html/rfc7523). ZIdentity validates the client assertion in one of the following ways, depending on your configuration.
- [Client JWKS URL](#client-assertion-jwks-url)
- [Certificates/Public Keys](#client-assertion-public-key-certificate)
When an API client sends an authentication request, ZIdentity verifies the client assertion or secret depending on the authentication mechanism used and issues the authorization grant (i.e., access token) upon successful verification. This access token is then used by the client to request access to the API resources.
Prerequisites
Organizations must meet the following prerequisites before using OneAPI:
- Make sure that your organization has a subscription to OneAPI and ZIdentity. To obtain access to these services, contact your Zscaler Account team.
- Register the client applications in the ZIdentity Admin Portal with the necessary scope and configure them appropriately. To learn more, see [Adding an API Client](/zidentity/adding-api-client).
Accessing OneAPI
You can access OneAPI using the following steps:
- [1. Locate your base URL.](#LocateBaseURL)
- [2. Authenticate the client and retrieve an access token.](#RetrieveAccessToken)
- [3. Make an API call.](#MakeAPICallUsingOAuth)
To learn more about rate limiting and HTTP status codes, see [Understanding Rate Limiting](/oneapi/understanding-rate-limiting) and [Understanding Response Codes & Error Messages](/oneapi/understanding-response-codes-error-messages). If you encounter any issues with the API, contact Zscaler Support.
[]The client assertion signature is validated using the public keys fetched from a URL hosted by the client. This URL publishes the public keys in the JSON Web Key (JWK) format. This method allows the client to rotate the public keys without requiring any manual updates in ZIdentity Admin Portal, as ZIdentity automatically retrieves the keys from the URL.
[]The client assertion signature is validated using the public keys or X.509 certificates directly uploaded to the ZIdentity Admin Portal. In this method, key rotation requires manual updates in ZIdentity Admin Portal.
[]OneAPI uses `api.zsapi.net` as the host in the base URL to which the API request is made. Each API has a unique basePath, resulting in different base URLs, listed as follows:
-
-
-
-
-
-
| API | Base Path | Base URL |
| --- | --------- | -------- |
| ZIA API | `/zia/api/v1` | `https://api.zsapi.net/zia/api/v1` |
| ZPA API | Supported Base Paths:`/zpa/mgmtconfig/v1``/zpa/mgmtconfig/v2``/zpa/userconfig/v1` | Supported Base URLs:`https://api.zsapi.net/zpa/mgmtconfig/v1``https://api.zsapi.net/zpa/mgmtconfig/v2``https://api.zsapi.net/zpa/userconfig/v1` |
| Zscaler Client Connector API | `/zcc/papi/public/v1` | `https://api.zsapi.net/zcc/papi/public/v1` |
| Cloud & Branch Connector API | `/ztw/api/v1` | `https://api.zsapi.net/ztw/api/v1` |
| ZDX API | `/zdx/v1` | `https://api.zsapi.net/zdx/v1` |
| ZIdentity API | `/ziam/admin/api/v1` | `https://api.zsapi.net/ziam/admin/api/v1` |
The base URI for the ZPA API is `/mgmtconfig/v1` and `/mgmtconfig/v2`. For endpoints to retrieve SCIM attribute details and SCIM group details, `/userconfig/v1` is used as the base URI.
All endpoints are relative to the base URL. For example, to call a ZIA API endpoint such as `/users`, you must send the API request to the following URL: `https://api.zsapi.net/zia/api/v1/users`. Similarly, API requests to ZPA, Zscaler Client Connector, and Cloud & Branch Connector endpoints must use the respective base URLs with the endpoints appended at the end.
Zscaler also supports a beta endpoint for OneAPI that uses `api.beta.zsapi.net` as the host. The basePath remains the same for each API, as listed in the preceding table. For example, to call the `/users` endpoint via beta, you must send the API request to the following URL: `https://api.beta.zsapi.net/zia/api/v1/users`.
[]To access OneAPI resources, the client application must obtain an authorization token (i.e., bearer token) by exchanging its credentials with ZIdentity). You must pass the access token onto subsequent calls to OneAPI for authentication.
To retrieve the access token, you must configure the client application to send a POST request along with the required parameters to ZIdentity's token endpoint: `https://``<Vanity Domain>``.zslogin.net/oauth2/v1/token`, where <Vanity Domain> refers to the domain name used by your organization. The request parameters and payload might vary depending on whether the client uses a secret or an assertion (via Private Key JWT authentication) for authentication, explained as follows:
- [Authentication Request Using Client Secret](#auth-request-client-secret)
- [Authentication Request Using Client Assertion (i.e., Private Key JWT)](#auth-request-private-key-jwt)
[]When making API calls, the client must pass the authorization token (i.e., bearer token) in each request for authentication. The client must present the access token in the request Authorization header using the Bearer authentication scheme.
API requests to ZPA endpoints require a `customerId` parameter, which represents the customer's ZPA tenant ID. Before you begin, ensure that you have obtained the `customerId` value in one of the following ways:
- [Obtain customer ID from the ZIdentity Admin Portal](#ZPA-customerId-zidentity-admin-portal)
- [Obtain customer ID from the ZPA Admin Portal](#customerId-ZPA-admin-portal)
The following are example requests to OneAPI resources along with responses:
- [Example ZIA API request](#zia-api-request-response)
- [Example ZPA API request](#zpa-api-request-response)
- [Example Zscaler Client Connector API request](#client-connector-api-request-response)
- [Example Cloud & Branch Connector API request](#cloud-branch-connector-api-request)
- [Example ZDX API request](#zdx-api-request)
- [Example ZIdentity API request](#zidentity-request-response)
When an API request is received, the Zscaler service validates the access token and accepts the request if authorization is successful. After successful validation, the client is allowed to access the requested API resources.
To send ad hoc requests to the API, Zscaler recommends using the [Postman REST API client](/oneapi/configuring-postman-rest-api-client).
ZIA and Cloud & Branch Connector APIs require an explicit activation step for the changes to take effect. After modifying any configurations in ZIA or Cloud & Branch Connector APIs, you must activate the changes by sending a POST request to `/status/activate` or `/ecAdminActivateStatus/activate` respectively.
[View more information about activating changes.](#zia-change-activation)
[]In this method of authentication, you must send the client credentials through Basic authentication in the format `clientID:ClientSecret` or through request payload as `client_id` and `client_secret` parameters. For more information, refer to [OAuth 2.0 RFC 6749, section 2.3](https://www.rfc-editor.org/rfc/rfc6749#section-2.3).
- Ensure that your [API client is registered](/zidentity/adding-api-client) with ZIdentity and you need to retrieve your client ID and secret from the ZIdentity Admin Portal to be sent in the authorization request.
- The authorization request must include an `audience` parameter set to `https://api.zscaler.com`.
The following is an example request for presenting client credentials using Basic authentication. In this example, you must replace the placeholder for the vanity domain with the domain name used by your organization and the placeholder for credentials with the Base64-encoded value of the `clientID:clientSecret` string.
`POST /oauth2/v1/token HTTP/1.1
Host: <Vanity Domain>.zslogin.net
Authorization: Basic <Credentials>
Content-Type: application/x-www-form-urlencoded
{
"grant_type": "client_credentials",
"audience": "https://api.zscaler.com"
}`
The following is an example request for client ID and client secret information sent in the request payload. In this example, the client ID and client secret are highlighted to indicate where you must enter the corresponding values.
`POST /oauth2/v1/token HTTP/1.1
Host: <Vanity Domain>.zslogin.net
Content-Type: application/x-www-form-urlencoded
{
"grant_type": "client_credentials",
"client_id": "<Client ID>",
"client_secret": "<Client Secret>",
"audience": "https://api.zscaler.com",
}`
If the request is successful, a 200 OK response is returned to the client with the access token and its expiration time in a JSON structure, as follows:
{
"access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6Ikp...vnI4T_H2rfze0c1Fk",
"token_type": "Bearer",
"expires_in": 3600
}
ZIdentity verifies the token using the client secret configured in the ZIdentity Admin Portal. The token expiration time is also configured in the ZIdentity Admin Portal. To learn more, see [Adding an API Client](/zidentity/adding-api-client).
If an unsuccessful POST request is made to the token endpoint, the response code returns a 400 error code.
[]In this authentication method, the client makes a POST request to the token endpoint with the `client_assertion` parameter, which presents the JWT that contains information for client authentication. To build the client assertion JWT:
- [a. Create a public-private key pair.](#create-key-pair-certificate)
- [b. Build a client assertion.](#build-client-assertion)
After you have the client assertion JWT ready, you can send a POST request to the token endpoint, as shown in the following example. The client ID and client assertion are highlighted to indicate where you must enter the corresponding values:
The authorization request must include an `audience` parameter set to `https://api.zscaler.com`.
POST /oauth2/v1/token HTTP/1.1
Host: <Vanity Domain>.zslogin.net
Content-Type: application/x-www-form-urlencoded
{
"grant_type"="client_credentials"
"client_id"="`<Client ID>`"
"client_assertion"="<Client Assertion JWT>"
"client_assertion_type"="urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
"audience"="https://api.zscaler.com"
}
If the request is successful, a 200 OK response is returned to the client with the access token and its expiration time in a JSON structure, as follows:
{
"access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6Ikp...vnI4T_H2rfze0c1Fk",
"token_type": "Bearer",
"expires_in": 3600
}
The client assertion is extracted from the request and is cryptographically verified by ZIdentity using the certificate or public key fetched from the JWKS endpoint or uploaded to the ZIdentity Admin Portal, depending on your configuration. The issuance and token expiration are also validated.
If an unsuccessful POST request is made to the token endpoint, a 400 error code is returned in the response.
[]Using the following example, you can look up categories for a specified list of URLs in ZIA by sending a POST request to `/urlLookup`. You must pass the bearer token obtained from ZIdentity in the request's Authorization header.
`url = "https://api.zsapi.net/zia/api/v1/urlLookup"
payload = [ "viruses.org", "facebook.com", "bbc.com" ]
headers = {
"Authorization": "Bearer <Access Token>"
}
response = requests.post(url, headers=headers, json=payload)
print(response.json())`
A successful response to this request returns the list of URLs with their category information:
[ {
"url": "viruses.org",
"urlClassifications": [
"MISCELLANEOUS_OR_UNKNOWN"
],
"urlClassificationsWithSecurityAlert": []
},
{
"url": "facebook.com",
"urlClassifications": [
"SOCIAL_NETWORKING"
],
"urlClassificationsWithSecurityAlert": []
},
{
"url": "bbc.com",
"urlClassifications": [
"NEWS_AND_MEDIA"
],
"urlClassificationsWithSecurityAlert": []
} ]
Zscaler recommends sending URLs for lookup in batches. Each request can have up to 100 URLs maximum, and each URL cannot exceed 1,024 characters.
If the API call fails due to an upgrade or scheduled maintenance of the API service, a 403 error code is returned, as shown in the following sample response. The API service supports only read operations via GET requests during this period.
HTTP/1.1 403
x-zscaler-mode: read-only
{
"code": "STATE_READONLY",
"message": "The API service is undergoing a scheduled upgrade and is in read-only mode."
}
When making API calls to ZIA, consider the following best practices:
- Ensure that the lifetime of an access token is set to a desirable value for the API clients in the ZIdentity Admin Portal.
- When updating a resource, always send a GET request before the PUT request. This retrieves the current values for the resource before you update the entire resource with new values.
[]Using the following example, you can get the list of all application segments in ZPA by sending a GET request to `/mgmtconfig/v1/admin/customers/``{customerId}``/application` and including the `customerId` parameter.
Use the following Python script to get a list of all application segments. The `customerId` parameter is highlighted to indicate where you must enter the ZPA tenant ID and a placeholder text is used where you must enter the bearer token obtained from ZIdentity.
`import requests
url = "https://api.zsapi.net/zpa/mgmtconfig/v1/admin/customers/{customerId}/application"
params = {
"page": 1,
"pagesize": 100
}
headers = {
"Authorization": "Bearer <Access Token>"
}
response = requests.get(url, headers=headers, params=params)
print(response.json())`
A successful response to this request returns the list of application segments with their details.
[View an example response](#zpa-example-response)
The following conditions apply when passing `microtenantId`, the unique identifier of the Microtenant, in a request:
- If you are within a Microtenant, you must pass the `microtenantId` field when making an API call to retrieve data from that Microtenant. The `microtenantId` can be obtained programmatically using the ZPA API. Access to certain operations are limited when you are within a Microtenant.
- If you are within the Default Microtenant, pass `microtenantId` as `0` when making requests to retrieve data from the Default Microtenant.
- Pass `microtenantId` as null to retrieve data from all customers associated with the tenant.
[]Using the following example, you can get a one-time password for a specific device from Zscaler Client Connector by sending a GET request to `/getOtp`​​, and including the `udid` parameter for the device.
The `udid` parameter represents the Unique Device Identifier generated for the device enrolled in Zscaler Client Connector. You can obtain this value programmatically using the Zscaler Client Connector API.
Use the following Python script to get a one-time password. In your script, enter the UDID for the device and include the bearer token obtained from ZIdentity where placeholders are highlighted in red.
`import requests
url = "https://api.zsapi.net/zcc/papi/public/v1/getOtp"
params = {
"udid": "{udid}"
}
headers = {
"Authorization": "Bearer <Access Token>"
}
response = requests.get(url, headers=headers, params=params)
print(response.json())
`
A successful request returns a response similar to the following:
`{
"otp" : "kg08abdcp1"
}`
When making API calls to Zscaler Client Connector, consider the following best practices:
- Use UTF-8 encoding for all endpoints (e.g., use the `encodeUriComponent()` function in JavaScript to encode to UTF-8).
- When updating a resource, always send a GET request before the PUT/POST request. This retrieves the current values for the resource before you update the entire resource with new values. After the update, the next GET request for that resource returns the new values. By using this practice, you avoid potentially missing updates between GET and PUT/POST calls.
- Prevent API call caching by adding a dummy argument with a randomly generated number to all URL request strings. For example: GET `/getOtp?_=123456?`
[]As a best practice, if you are making multiple configuration changes, Zscaler recommends grouping the changes and activating once. You can retrieve the activation status by sending a GET request to `/status` for ZIA or `/ecAdminActivateStatus` for Cloud & Branch Connector. However, you cannot revert a change and you cannot cancel any queued activations.
To avoid race conditions, do not manually change configuration settings via the ZIA Admin Portal or Zscaler Cloud & Branch Connector Admin Portal while your scripts are running. The Zscaler service might lock a configuration while a user is editing. When multiple users are editing concurrently, only one user's change succeeds, while the remaining users might receive a [409 error](/oneapi/understanding-response-codes-error-messages) (EDIT_LOCK_NOT_AVAILABLE).
If you encounter a race condition and a 409 error code is returned, Zscaler recommends adding a wait cycle of a few seconds and retrying to recover.
[]
`{
"totalPages":"1",
"list":[
{
"creationTime":"1617135729",
"modifiedBy":"7207654021241",
"id":"7207654021241",
"domainNames":[
"example.com"
],
"name":"example",
"serverGroups":[
{
"id":"7207654021241",
"creationTime":"1617134731",
"modifiedBy":"7207654021241",
"name":"SIPA",
"enabled":true,
"configSpace":"DEFAULT",
"dynamicDiscovery":true
}
],
"enabled":true,
"passiveHealthEnabled":true,
"tcpPortRanges":[
"443",
"443"
],
"doubleEncrypt":false,
"configSpace":"DEFAULT",
"bypassType":"NEVER",
"healthCheckType":"DEFAULT",
"isCnameEnabled":true,
"ipAnchored":true,
"healthReporting":"ON_ACCESS",
"segmentGroupId":"7207654021241",
"segmentGroupName":"SIPA"
},
{
"modifiedTime":"1617135436",
"creationTime":"1613673797",
"modifiedBy":"7207654021241",
"id":"7207654021241",
"domainNames":[
"www.example.com"
],
"name":"example",
"serverGroups":[
{
"id":"7207654021241",
"creationTime":"1613673769",
"modifiedBy":"7207654021241",
"name":"ZPA",
"enabled":true,
"configSpace":"DEFAULT",
"dynamicDiscovery":true
}
],
"enabled":true,
"passiveHealthEnabled":true,
"tcpPortRanges":[
"80",
"80"
],
"doubleEncrypt":false,
"configSpace":"DEFAULT",
"bypassType":"NEVER",
"healthCheckType":"DEFAULT",
"isCnameEnabled":true,
"ipAnchored":false,
"healthReporting":"ON_ACCESS",
"segmentGroupId":"7207654021241",
"segmentGroupName":"ZPA"
},
{
"creationTime":"1617134731",
"modifiedBy":"7207654021241",
"id":"7207654021241",
"domainNames":[
"docs.example.com"
],
"name":"docs.example.com",
"serverGroups":[
{
"id":"7207654021241",
"creationTime":"1617134731",
"modifiedBy":"7207654021241",
"name":"SIPA",
"enabled":true,
"configSpace":"DEFAULT",
"dynamicDiscovery":true
}
],
"enabled":true,
"passiveHealthEnabled":true,
"tcpPortRanges":[
"54",
"65535"
],
"doubleEncrypt":false,
"configSpace":"DEFAULT",
"bypassType":"NEVER",
"healthCheckType":"DEFAULT",
"isCnameEnabled":true,
"ipAnchored":true,
"healthReporting":"ON_ACCESS",
"segmentGroupId":"7207654021241",
"segmentGroupName":"SIPA"
},
{
"creationTime":"1613762719",
"modifiedBy":"7207654021241",
"id":"7207654021241",
"domainNames":[
"www.example.com"
],
"name":"example",
"serverGroups":[
{
"id":"7207654021241",
"creationTime":"1613673769",
"modifiedBy":"7207654021241",
"name":"ZPA",
"enabled":true,
"configSpace":"DEFAULT",
"dynamicDiscovery":true
}
],
"enabled":true,
"passiveHealthEnabled":true,
"tcpPortRanges":[
"443",
"443"
],
"doubleEncrypt":false,
"configSpace":"DEFAULT",
"bypassType":"NEVER",
"healthCheckType":"DEFAULT",
"isCnameEnabled":true,
"ipAnchored":false,
"healthReporting":"ON_ACCESS",
"segmentGroupId":"7207654021241",
"segmentGroupName":"ZPA"
},
{
"creationTime":"1616516461",
"modifiedBy":"7207654021241",
"id":"7207654021241",
"domainNames":[
"*.example.com"
],
"name":"test-wildcard",
"description":"&#x2a;&#x2e;example&#x2e;com",
"serverGroups":[
{
"id":"7207654021241",
"creationTime":"1613673769",
"modifiedBy":"7207654021241",
"name":"ZPA",
"enabled":true,
"configSpace":"DEFAULT",
"dynamicDiscovery":true
}
],
"enabled":true,
"passiveHealthEnabled":true,
"tcpPortRanges":[
"443",
"443",
"80",
"80"
],
"doubleEncrypt":false,
"configSpace":"DEFAULT",
"bypassType":"NEVER",
"healthCheckType":"DEFAULT",
"isCnameEnabled":true,
"ipAnchored":false,
"healthReporting":"ON_ACCESS",
"segmentGroupId":"7207654021241",
"segmentGroupName":"ZPA"
}
]
}`
[]Using the following example, you can make an API call to the `/ecgroup` endpoint to get the list of Cloud & Branch Connector groups available. You must pass the bearer token obtained from ZIdentity in the request's Authorization header.
`import requests
url = "https://api.zsapi.net/ztw/api/v1/ecgroup"
headers = {
"Authorization": "Bearer <Access Token>"
}
response = requests.get(url, headers=headers)
print(response.json())`
A successful response to this GET request returns the following response containing a list of Cloud & Branch Connector groups available to you.
[View an example response](#ExampleGETecgroupResponse)
When making API calls, consider the following best practices:
- Use UTF-8 encoding for all endpoints (e.g., use the `encodeUriComponent()` function in JavaScript to encode to UTF-8).
- When updating a resource, always send a GET request before the PUT request. This retrieves the current values for the resource before you update the entire resource with new values. After the update, the next GET request for that resource returns the new values. By doing this, you avoid potentially missing updates between GET and PUT calls.
[]
[
{
"id": 63260789,
"name": "zs-cc-vpc-02de960b4c73a7275-us-west-2a",
"desc": "Auto created from ami-0c0f8d637a04769ea_i-04f78174f6daf4792",
"deployType": "CLOUD",
"status": [
"CLOUD"
],
"platform": "AWS",
"awsAvailabilityZone": "US_WEST_2A",
"location": {
"id": 63260784,
"name": "us-west-2-vpc-02de960b4c73a7275"
},
"maxEcCount": 0,
"provTemplate": {
"id": 316001,
"name": "aws-zwlc-id"
},
"tunnelMode": "UNENCRYPTED",
"ecVMs": [
{
"id": 63260794,
"name": "zs-cc-vpc-02de960b4c73a7275-us-west-2a-VM-B5bV5",
"status": [
"REGISTERED",
"PKG_REPO_REGISTERED"
],
"operationalStatus": "INACTIVE",
"provTemplate": {
"id": 316001,
"name": "aws-zwlc-id"
},
"formFactor": "SMALL",
"managementNw": {
"id": 350251,
"ipStart": "10.1.200.178",
"ipEnd": "0.0.0.0",
"netmask": "255.255.255.0",
"defaultGateway": "10.1.200.1",
"nwType": "AUTOMATIC",
"dns": {
"id": 350249,
"ips": [
"10.1.0.2"
],
"dnsType": "AUTOMATIC"
}
},
"ecInstances": [
{
"id": 63260797,
"name": "zs-cc-vpc-02de960b4c73a7275-us-west-2a-VM-B5bV5_INSTANCE_1_MnEgQ",
"flags": "REGISTERED",
"ecInstanceType": "SME",
"registerTime": 0,
"natIp": "52.38.213.147",
"serviceNw": {
"id": 350258,
"ipStart": "10.1.200.33",
"ipEnd": "0.0.0.0",
"netmask": "255.255.255.0",
"defaultGateway": "10.1.200.1",
"nwType": "AUTOMATIC",
"dns": {
"id": 350257,
"ips": [
"10.1.0.2"
],
"dnsType": "AUTOMATIC"
}
},
"virtualNw": {
"id": 350256,
"ipStart": "0.0.0.0",
"ipEnd": "0.0.0.0",
"netmask": "0.0.0.0",
"defaultGateway": "0.0.0.0",
"nwType": "AUTOMATIC",
"dns": {
"id": 350254,
"ips": [
"0.0.0.0"
],
"dnsType": "AUTOMATIC"
}
}
}
],
"cityGeoId": 5714964,
"natIp": "52.38.213.147",
"ziaGateway": "165.225.50.12",
"zpaBroker": "136.226.57.254",
"buildVersion": "346637",
"lastUpgradeTime": 1678010276,
"upgradeStatus": 0,
"upgradeStartTime": 0,
"upgradeEndTime": 7200,
"upgradeDayOfWeek": 1,
"haStatus": "DISABLED"
}
]
},
{
"id": 63260807,
"name": "zs-cc-vpc-07c37249a25154547-us-east-2a",
"desc": "Auto created from ami-06a12e35f23ca5f7a_i-0bf0bbc515f4c7f64",
"deployType": "CLOUD",
"status": [
"CLOUD"
],
"platform": "AWS",
"awsAvailabilityZone": "US_EAST_2A",
"location": {
"id": 63260805,
"name": "us-east-2-vpc-07c37249a25154547"
},
"maxEcCount": 0,
"provTemplate": {
"id": 316001,
"name": "aws-zwlc-id"
},
"tunnelMode": "UNENCRYPTED",
"ecVMs": [
{
"id": 63260809,
"name": "zs-cc-vpc-07c37249a25154547-us-east-2a-VM-0TbUx",
"status": [
"REGISTERED",
"PKG_REPO_REGISTERED"
],
"operationalStatus": "INACTIVE",
"provTemplate": {
"id": 316001,
"name": "aws-zwlc-id"
},
"formFactor": "SMALL",
"managementNw": {
"id": 350260,
"ipStart": "10.1.200.201",
"ipEnd": "0.0.0.0",
"netmask": "255.255.255.0",
"defaultGateway": "10.1.200.1",
"nwType": "AUTOMATIC",
"dns": {
"id": 350259,
"ips": [
"10.1.0.2"
],
"dnsType": "AUTOMATIC"
}
},
"ecInstances": [
{
"id": 63260813,
"name": "zs-cc-vpc-07c37249a25154547-us-east-2a-VM-0TbUx_INSTANCE_1_4emcc",
"flags": "REGISTERED",
"ecInstanceType": "SME",
"registerTime": 0,
"natIp": "3.20.194.248",
"serviceNw": {
"id": 350268,
"ipStart": "10.1.200.105",
"ipEnd": "0.0.0.0",
"netmask": "255.255.255.0",
"defaultGateway": "10.1.200.1",
"nwType": "AUTOMATIC",
"dns": {
"id": 350266,
"ips": [
"10.1.0.2"
],
"dnsType": "AUTOMATIC"
}
},
"virtualNw": {
"id": 350264,
"ipStart": "0.0.0.0",
"ipEnd": "0.0.0.0",
"netmask": "0.0.0.0",
"defaultGateway": "0.0.0.0",
"nwType": "AUTOMATIC",
"dns": {
"id": 350263,
"ips": [
"0.0.0.0"
],
"dnsType": "AUTOMATIC"
}
}
}
],
"cityGeoId": 4509177,
"natIp": "3.20.194.248",
"ziaGateway": "165.225.8.22",
"zpaBroker": "165.225.100.203",
"buildVersion": "346637",
"lastUpgradeTime": 1677999488,
"upgradeStatus": 0,
"upgradeStartTime": 0,
"upgradeEndTime": 7200,
"upgradeDayOfWeek": 1,
"haStatus": "DISABLED"
}
]
}
]
[]
Using the following Python script example, you can start a deep tracing session on a specific device in ZDX by sending a POST request to the endpoint `/devices/``{deviceid}``/deeptraces` and including the `deviceid` as the parameter for the device. Starting a deep tracing session allows you to gather comprehensive diagnostics details about a specific device that is having trouble connecting to the network. You must pass the bearer token obtained from ZIdentity in the request's Authorization header as highlighted in red.
`url = "https://api.zsapi.net/zdx/v1/devices/{device_id}/deeptraces"
payload = {
"session_name": "{sessionName}",
"session_length_minutes": 5,
"probe_device": True
}
headers = {
"Authorization": "Bearer <Access Token>"
}
response = requests.post(url, headers=headers, json=payload)
print(response.json())`
A successful request returns a response similar to the following:
`{
"trace_id": 0,
"status": "not_started",
"expected_time": 0
}`
[]In the following example, you can get a list of users from the ZIdentity Admin Portal by sending a GET request to `/users`. Use the following Python script to get a list of users. Send the GET request to the endpoint. Include the bearer token obtained from ZIdentity where placeholders are highlighted in red.
`import http.client
conn = http.client.HTTPConnection("https://api.zsapi.net/ziam/admin/api/v1")
payload = ''
headers = {
'Authorization': 'Bearer <Access Token>'
}
conn.request(
"GET",
"/users?limit=100&offset=0&loginname=bbb@bbc.com",
payload,
headers
)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
`
A successful response to this GET request returns the following response containing a list of users with the details:
`{
"pageOffset": 0,
"pageSize": 100,
"records": [
{
"loginName": "bbb@bbc.com",
"displayName": "ad",
"primaryEmail": "bbb@bbc.com",
"department": {},
"status": true,
"customAttrsInfo": {},
"id": "ihv1284ang34c",
"source": "UI",
"idp": {
"id": "h1v0q1nac03tk",
"name": "okta"
}
}
],
"results_total": 1
}`
When making API calls to ZIdentity, consider the following best practices:
- Use UTF-8 encoding for all endpoints (e.g., use the `encodeUriComponent()` function in JavaScript to encode to UTF-8).
- When updating a resource, always send a GET request before the PUT/POST request. This retrieves the current values for the resource before you update the entire resource with new values. After the update, the next GET request for that resource returns the new values. By using this practice, you avoid potentially missing updates between GET and PUT/POST calls.
- []From the ZIdentity Admin Portal, go to **Integration** > **API Resources**.
-
Click the **View** icon for Zscaler APIs.
The **API Resource** window appears.
- In the **API Resource** window, see the Zscaler services that are linked to your tenant and the available scopes.
-
Click **ZPA OneAPI** to expand the resource.
Your customer ID is displayed as part of the scope and you can copy this value.
[See image.](#zpa-customerId-zidentity-api-resources)
Alternatively, you can view the customer ID by going to **Integration** > **API Clients** > **Add/Edit API Client** > **Resources**.
[See image.](#zpa-customerId-zidentity-api-client)
-
[]From the ZPA Admin Portal, go to **Configuration & Control** > **Public API** > **API Keys**.
The **API Keys** page appears.
-
On the **API Keys** page, click **Copy Customer ID**.
[See image.](#zpa-customerId-zpa-admin-portal)
[]You need to create an asymmetric key pair of public and private keys and sign the JWT with your private key to use for client authentication. The public key or an X.509 certificate containing the public key is shared with ZIdentity to verify the digital signature of the client's JWT assertion. The X.509 certificate is a digital document binding a public key to the identity of a user, service, or device. Alternatively, you can host the public key in a JWKS URL and share the URL with ZIdentity.
-
Create a public-private key pair using standard tooling, and optionally obtain an X.509 certificate for your public key issued by a Certificate Authority (CA). For testing purposes, you can also create and use a self-signed certificate.
The following example demonstrates how to create an RSA key pair of size 2,048 bits using OpenSSL. You can adjust the bit size based on your security requirements (e.g., 3,072 or 4,096 bits for stronger security).
`openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
Generating RSA private key, 2048 bit long modulus
.............................+++++
.................+++++
//Private key is created in .pem format//
ls -la
private_key.pem`
The RSA private key is created in PEM format and this is followed by extracting a public key from the private key.
`openssl rsa -pubout -in private_key.pem -out public_key.pem
writing RSA key
//Public key is generated in .pem format//
ls -la
private_key.pem public_key.pem`
In this example, a public key certificate in PEM format is created.
- Additionally, you can host your public key at a publicly accessible endpoint (e.g., Amazon S3 bucket) to allow ZIdentity to fetch the public key from this endpoint directly. This endpoint becomes your JWKS URL.
[]Prior to configuring the assertion token, you must have [registered your API client](/zidentity/adding-api-client) with ZIdentity and retrieved the client ID value.
You can construct a client assertion token using standard tooling or [third-party libraries](https://www.jwt.io/libraries) that natively support this functionality, instead of building it from scratch. This assertion token is expected to contain the JWT claims.
The following example uses the JSON Web Token (JWT) Debugger ([jwt.io](https://www.jwt.io)) to build a JWT that can be used for testing purposes. However, any JWT debugging tool can be used to perform this task.
- Go to [jwt.io](https://www.jwt.io).
- Click **JWT Encoder**.
-
Under **Header**, enter the following JSON values:
`{
"alg": "RS256",
"type": "JWT"
}`
ZIdentity supports RS256 and ES256 encryption algorithms for the key pair. This example uses the RS256 algorithm.
-
Under **Payload**, enter the following required fields along with their values:
`{
"iss": "<API client ID>",
"sub": "<API client ID>",
"aud": "<https://<Vanity Domain>.zslogin.net>",
"iat": <Current Time>,
"exp": <Expiration Time>
}`
In the payload, replace the placeholders with the following values:
- **iss**: The Issuer claim corresponds to your client ID obtained from the ZIdentity Admin Portal.
- **sub**: The Subject claim corresponds to your client ID obtained from the ZIdentity Admin Portal.
- **aud**: The Audience specifies the ZIdentity base URL that includes the vanity domain name used by your organization.
- **iat**: The Issued At claim specifies the current time in epoch format.
- **exp**: This claim specifies the Expiration Time in epoch format.
The following is a payload example with the required claims and their values:
`{
"iss": "iq41q3fpgg6st",
"sub": "iq41q3fpgg6st",
"aud": "http://safemarch.zslogin.net",
"iat": 1759138668,
"exp": 1959189083
}`
- Under **Sign JWT**, enter your private key (i.e., `private_key.pem` from a [previous step](#key-pair-certificate)) that corresponds to the public key configured in the ZIdentity Admin Portal.
-
Click **Generate Example** in the right pane and select a signing algorithm.
A JWT is generated and displayed. This JWT would be sent as the client assertion in the access token request.
[See image.](#create-jwt-example)
[]![ZPA Customer ID in ZIdentity Admin Portal](/downloads/oneapi/getting-started-oneapi/getting-started/zpa-customerid-zslogin-option1.png)
[]![ZPA Customer ID in ZIdentity Admin Portal](/downloads/oneapi/getting-started-oneapi/getting-started/zpa-customerid-zslogin-option2.png)
[]![ZPA Customer ID in ZPA Admin Portal](/downloads/oneapi/getting-started-oneapi/getting-started/copy-customerId-ZPA-admin-portal.png)
[]![Creating JSON Web Token (JWT) using JWT Encoder](/downloads/oneapi/getting-started-oneapi/getting-started/create-jwt-example.png)